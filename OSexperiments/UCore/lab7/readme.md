# lab7 Report

## 练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

在trap.c中，当发生时钟中断时，需要调用run_time_list函数。在lab6中，互斥通过lock实现，在lab7中则使用信号量实现互斥，此外增加了等待队列、计时器、禁用中断等。

信号量结构体有计数值value和等待队列wait_queue两个成员，相关的函数是`void sem_init(semaphore_t *sem, int value)`,`void up(semaphore_t *sem)`,`void down(semaphore_t \*sem)`和`bool try_down(semaphore_t \*sem)`，up函数对应V操作，首先要关闭中断，并测试等待队列是否为空，如果为空则增加value，否则唤醒一个等待进程。最后开中断。down函数对应P操作，首先关中断，若此时value的值大于0，表示能够获得信号量，则减小value后开启中断即可。否则开中断，并将当前进程加入到等待队列中，进程调度唤醒其他进程。当占有资源的进程释放所需资源时，该进程再次被唤醒，先关中断，将其从等待队列中移除，并开中断。

用户态的进程/线程的信号量的数据结构与内核态相同。用户态进程/线程的信号量的相关操作通过系统调用来完成。每当用户进程调用信号量相关函数时，都会进入系统调用，由内核进行处理，之后再返回到用户态继续执行。相比于为内核提供的信号量机制，用户态进程/线程由于要执行中断操作等特权指令，需要通过系统调用进入内核态使用内核信号量机制。


## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

条件变量和管程分别用`condvar`和`monitor`两个结构实现。等待条件变量和通知条件变量的变化用`cond_wait`和`cond_signal`两个函数完成。若某个进程执行了cond_wait函数，表明该进程需因要的某个条件变量不满足需求而进入休眠状态。等待这个条件变量的休眠进程数cv.count增加。此时如果monitor.next_count大于0，表示至少有1个进程执行cond_signal函数后进入休眠状态，等待monitor.next信号量上，则需要唤醒等待该条件量的另一个进程，然后该进程在cv.sem上休眠。当进程A被唤醒时，减少cv.count，表示等待此条件变量的睡眠进程个数减少了一个，可继续执行。如果monitor.next_count小于等于0，表明目前没有进程执行cond_signal函数进入休眠，则需要唤醒的是由于互斥条件限制而无法进入管程的进程，即唤醒在monitor.mutex上休眠的进程。然后当前进程在cv.sem上休眠，直到被唤醒时，减少cv.count，表示等待此条件的睡眠进程个数减少，可继续执行。


执行cond_signal函数时，首先当前进程测试cv.count，如果不大于0，则表示当前没有执行cond_wait而进入休眠状态的进程，函数直接返回。如果cv.count大于0，这表示当前有执行cond_wait而进入休眠状态的进程，因此需要唤醒在cv.sem上等待出入休眠状态的进程。由于只允许一个进程在管程中执行，所以一旦当前进程唤醒了其他进程，自身就要进入休眠状态，即增加monitor.next_count，让当前进程在信号量monitor.next上进入休眠状态，直到被唤醒时，减少monitor.next_count。


用户态条件变量机制与内核态实现基本一致，即由一个变量的操作来判断当前资源的使用情况，需要系统原子操作的支持，通过系统调用在用户态实现管程的处理函数。不同点在于用户进程需要通过系统调用来实现中断屏蔽等一些需要通过在内核态使用特权指令完成的操作。

能够不基于信号量机制来实现条件变量，但是需要有一个锁机制保证每次对等待队列的增删操作以及等待个数修改的操作是互斥的，即cond_signal, cond_wait函数前后需要加一个互斥锁。