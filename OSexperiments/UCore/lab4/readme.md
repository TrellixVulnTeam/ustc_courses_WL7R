## 练习1：分配并初始化一个进程控制块

初始化一个进程控制块主要是对进程快结构的成员变量进行初始化赋值。state赋值为PROC_UNINIT设置进程为“初始”态，pid设置为-1，表示进程号为初始化，cr3赋值为boot_cr3表示使用内核页目录表的基址。其他的指针成员变量都赋值为NULL，并将上下文和名称置零。


* 请说明proc_struct中struct context context和struct trapframe \*tf成员变量含义和在本实验中的作用是啥？


context是进程执行的上下文，用于在进程切换时保存当前ebx、ecx、edx、esi、edi、esp、ebp、eip八个寄存器，即保存当前进程的执行状态上下文。

tf是中断帧，当进程从用户空间转换到内核空间时，中断
帧记录了进程在被中断前的状态。当内核需要切换回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。

## 练习2：为新创建的内核线程分配资源

新创建的内核线程分配资源的过程主要是：
1. 申请一个初始化后的进程控制块
2. 为子内核线程建立栈空间
3. 拷贝或者共享内存空间
4. 在进程控制块中设置中断帧和上下文
5. 为进程分配进程号
6. 将新分配的进程控制块插入哈希表和进程链表；
7. 返回进程的进程号

* 请说明ucore是否做到给每个新fork的线程一个唯一的id？

是。

线程的PID由get_pid函数产生，该函数最终返回的条件是遍历全部进程，其进程号与将返回的新的进程号不同，从而保证了新的进程的pid唯一。同时通过next_safe这个变量确保进程号在一个合法范围内。

## 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。

proc_run的执行过程为：

1. 保存中断位并关中断
2. 将current指针指向将要执行的进程
3. 更新TSS中的栈顶指针
4. 加载新的页表
5. 调用switch_to进行上下文切换
6. 当调用proc_run的进程重新执行之后恢复中断位

* 在本实验的执行过程中，创建且运行了几个内核线程？

两个:

idleproc，这个线程不断试探是否有可以调度的进程，有则执行；

initproc，本实验中的仅输出一段字符串。

* 语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由.

保存中断位并关中断，在进程重新执行时恢复中断位。关中断是防止进程切换过程被中断打断而不得不转中断服务例程。