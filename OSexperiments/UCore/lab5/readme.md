# lab5 report

## 练习1: 加载应用程序并执行

需要将中断帧的代码段设置为USER_CS，数据段、附加段和堆栈段设置为USER_DS，栈顶指针设置为USTACKTOP，代码段指针设置为ELF文件的入口地址即elf->e_entry，并将EFLAGS的中断位置1。

当一个进程被选择占用CPU时，将切换内核态的上下文即ebx、ecx、edx、esi、edi、esp、ebp、eip八个寄存器和内核栈。完成后，用IRET指令将trapframe中的用户态上下文恢复，在用户态中执行进程。

## 练习2: 父进程复制自己的内存空间给子进程

首先获取源页面和目标页面的内核虚拟地址，之后使用memcpy将源页的数据拷贝到目标页，最后建立目标页面和地址的映射关系即可。其他一些需要改动的细节有，在IDT中将系统调用设置为用户态可用，并在产生时钟中断时取消对中断信息的打印并请求进行CPU调度。 

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

- fork

    1. 检查当前总进程数目是否已经到达上限，如果是，返回E_NO_FREE_PROC并结束
    2. 申请一个初始化后的进程控制块
    3. 为内核进程（线程）建立栈空间
    4. 拷贝或者共享内存空间
    5. 建立trapframe以及上下文
    6. 为进程分配一个进程号
    7. 将进程控制块加入哈希表和进程链表
    8. 返回进程的进程号

- exec

    1. 检查进程名称的地址和长度是否合法，如果合法则将名称暂时保存在函数栈中
    2. 将进程原先的内存全部释放
    3. 将进程代码加载进内存
    4. 设置进程名称。

- wait实现

    1. 检查用于保存返回码的指针地址位于合法的范围内
    2. 根据进程号找到需要等待的子进程的进程控制块，如果没有需要等待的子进程，返回E_BAD_PROC
    3. 如果子进程正在可执行状态中，那么将当前进程休眠，等被唤醒后再次尝试
    4. 如果子进程处于僵尸状态，则释放其进程控制块

- exit实现

    1. 释放进程的虚拟内存空间；
    2. 设置进程状态为PROC_ZOMBIE同时设置返回码
    3. 如果父进程正在等待当前进程，则唤醒父进程
    4. 将当前进程的所有子进程变为init的子进程
    5. 主动调用调度函数请求调度。

- 系统调用实现

应用程序将请求的系统调用编号放入eax，系统调用的参数放在edx、ecx、ebx、edi、esi寄存器，然后执行INT 0x80指令请求操作系统完成系统调用。操作系统根据中断号0x80得知是系统调用，根据系统调用号和参数执行相应的操作。

- 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？

    - fork：创建一个子进程，将子进程的状态从UNINIT态变为RUNNABLE态，不改变父进程的状态
    - exec：不改变进程的状态
    - wait：如果有已经结束的子进程或者没有子进程，则调用立刻结束，不影响进程状态。否则，进程等待子进程结束，从RUNNIG态变为SLEEPING态
    - exit：进程从RUNNIG态变为ZOMBIE态

- 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。
```
 |
 |  alloc_proc
 |
\ /
UINIT
 |
 |  wakeup_proc
 | 
\ /             wakeup_proc
RUNABLE <----------------------------- SLEEPING
 |   \_______                           / \
 |  do_kill  \                           |
 |            \schedule                  | do_wait
\ /            \                         |
ZOMBIE           \--->RUNNING--------------
/ \                     |
 |______________________|
         do_exit
```
## 扩展练习 Challenge ：实现 Copy on Write 机制

在vmm.c中将dup_mmap函数中将share变量设置为1，启用共享。在pmm.c中在copy_range函数中添加对共享的处理，如果share为1，那么将子进程的页面映射到父进程的页面。两个进程共享一个页面之后，此时无论任何一个进程修改页面，都会影响另外一个页面，因此子进程和父进程对于这个共享页面都设置为只读。当进程尝试修改只读的内存页面的时候，将触发Page Fault异常，在错误代码中P=1,、W/R=1，由此可依据错误代码最低两位都为1的断定进程访问了共享的页面，则内核重新分配页面，拷贝页面内容并建立映射关系，这一点在do_pgfault中实现。

具体实现可见代码。