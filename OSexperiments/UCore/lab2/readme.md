# lab2 report
## 练习1：实现 first-fit 连续物理内存分配算法

实现见/lab2/kern/mm/default_mm.c

```
连续内存的维护由一个双向链表来实现，其结构如下图所示：

-----------------------------------------------------|
|   __    __    __    __    __    __    __    __     |
|--|  |->|  |->|  |->|  |->|  |->|  |->|  |->|  |<----
-->|__|<-|__|<-|__|<-|__|<-|__|<-|__|<-|__|<-|__|-----
|    \_free_area                                     |
------------------------------------------------------

初始化时除了设置必要的位以外，只需将以base开始的连续n个page插入链表即可。之后可以通过与插入方向相反的指针顺序访问到这段连续的内存。
在参考答案中，是使用list_add_before来插入page，之后通过list_next来顺序访问。在本次实现中在插入过程中使用了list_add，所以之后的顺序访问就使用list_prev。两种实现方式在本质上并无区别。

分配内存时，从free_area->prev开始查找符合条件的内存块，找到即是返回的结果。如果内存块大于需求，还要进行分割。

回收内存时，仍然从头开始顺序查找，查找的目标是地址大于被释放内存块的地址的第一页。此处查找到结果，应先跳出查找目标的循环体，再做后续处理。（因为可能所有的内存空间都已经被占用，链表只剩free_area）被释放的内存要和前后相邻的空闲内存块合并。向后合并可根据其后一页是否与其相邻来判断。向前的合并可以一直向前便利直到找到一块空闲内存的头，然后与其合并即可。
```
* first fit算法的进一步改进空间

	当前实现的first fit算法在查找符合条件的内存块以及修改链表时都是依次处理，为线性复杂度。这两中处理都可以进一步优化，但是需要每一块连续内存保存其他的信息。

	对于块查找的优化，如果在每一块连续内存的头指针中，增加一个保存指向这段连续内存的末页的指针变量，则在分配内存查找满足条件的内存块时，遇到空间不够的内存块可以直接跳跃到其末页再继续查找，而不需要依次遍历这段内存块的内部。同样的道理，释放内存后，被释放的内存块在向前合并时，如果在每一块连续内存的末页保存其块大小，同样可以直接完成合并而不需要依次遍历。

	基于同样的方法，对于双向链表的维护，目前链表的插入和删除操作都是依次操作，为线性复杂度，可以被改进到仅修改块首位连接的常数复杂度。这两种优化方法的优化程度取决于内存分配的粒度，若是每次分配的页面都较小，这种优化的效果就比较小，反而引入了额外的存储空间。
	实现见/lab2/kerl/mm/default_pmm.c

## 练习二 实现寻找虚拟地址对应的页表项
```
依据线性地址查询页目录表，如果对应的页表项存在，则依据表项的索引获得页表项的地址并返回。如果对应的页表项不存在，则根据是否需要创建页表项的布尔变量参数分配新的物理页（可能为空）。对于新分配的页要增加其页索引数，并完成页初始化。最后获取其物理地址并设置相应的位，保存在也目录表中，并返回该表项的虚拟地址。

实现见/lab2/kern/mm/pmm.c
```

* 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含
义和以及对ucore而言的潜在用处

	页的分配是以物理页为单位的，其地址要求按照页大小，即4096字节对齐。PDE和PTE的高20位用于保存对应页表和页的基地址，低12位可以用作表项的标志位，对表项的属性进行说明，如是否存在，是否可写以及访问权限等。

* 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

	应将将引发异常的地址保存在cr2寄存器中，并设置错误代码，触发page fault异常，让操作系统在内核态进行处理。

## 练习三：释放某虚地址所在的页并取消对应二级页表项的映射
```
将取消页的引用数减一，如果该页的引用数为0，则释放该页，将该页的内容清空，最后刷新TLB
 
实现见/lab2/kern/mm/pmm.c
```


* 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有
无对应关系？如果有，其对应关系是啥？

	页目录项和页表项中都保存着一个物理页面的地址，对于页目录项，这个物理页面是页表的地址，对于页表，这个物理页面表示已经分配的物理页。每一个物理页面在Page数组中都有相应的记录，保存着该物理页是否被分配，被引用的数量和是否被内核保留等信息。

* 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？鼓励通过编程来具体完成这个问题

需要以下几个步骤
1. 在链接脚本中将内核的虚拟地址起始地址改为0x100000

```
/* /lab2/tools/kernel.ld */
SECTIONS {
    /* Load the kernel at this address: "." means the current address */
    . = 0x100000;

...
```

2. 将虚拟内存起始地址改为0x0

```c
/* /lab2/kern/mm/memlayout.h */

#define KERNBASE  0x00000000

```

3. 删除0-4M空间内存映射部分

```c
/* /lab2/kern/mm/pmm.c

//disable the map of virtual_addr 0~4M
boot_pgdir[0] = 0;

//now the basic virtual memory map(see memalyout.h) is established.
//check the correctness of the basic virtual memory map.
check_boot_pgdir();

*/
```


在本次实验的测试过程中，仅完成练习二的get_pte()函数无法通过check_pgdir()函数的测试，需要完成练习三的任务才会通过全部测试。完成练习一的任务后即可通过check_alloc_page()的测试。