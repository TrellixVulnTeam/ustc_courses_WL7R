# Lab8 report

## 练习一

### 完成读文件操作的实现

打开文件的基本流程为：

在sh.c文件中，由main函数可以看出 这是一个单独的测试文件系统的文件，通过main->reopen->open->sys_open->syscall系统调用进入内核态，之后通过终端处理例程，调用sys_open->sysfile_open， 至此，文件访问接口层的处理流程完成。

然后进入文件系统抽象层，通过file_open分配了一个空闲的file数据结构，file_open函数通过调用vfs_open和参数path来找到文件对应的inode结构的vfs索引节点， 而vfs_open函数调用了vfs_lookup函数找到path对应的inode数据结构，并调用vop_open函数打开文件。 总体调用顺序为file_open->vfs_open->vfs_lookup(vop_open)

vfs_lookup函数是一个针对目录的操作函数，需要通过path找到目标文件首先要 找 到根 目录 ”/”， 然后又由接下 来的调用vfs_lookup->vop_lookup->get_device->vfs_get_bootfs 找到根目录”/”对应的inode数据结构node，然fs_lookup会调用vop_lookup找到对应文件的索引节点。找到索引节点之后，再调用宏定义vop_open打开文件。

要实现文件的打开，首先需要处理起始处没有对齐到块的部分，再以块为单位循环处理中间部分，最后处理末尾剩余部分。每部分的处理都调用sfs_bmap_load_nolock函数得到blkno对应的inode编号，并调用sfs_rbuf或sfs_rblock函数读取数据（中间部分调用sfs_rblock，起始和末尾部分调用sfs_rbuf），调整相关变量即可。

具体实现见代码。

"UNIX的PIPE机制"的概要设方案

管道是进程间通信的一个基础设施，管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能以一个先进先出的方式来接收数据。

管程是由内核管理的一个缓冲区，一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。

当Process 1向PIPE中写入时，它利用标准的库函数`write`完成向指定内存空间的写操作。当满足如下条件时，实际的内存复制工作才被执行：

- 内存中有足够的空间可容纳所有要写入的数据；
- 内存没有被Process 2锁定。

如果同时满足上述条件，首先锁定内存，然后复制数据。否则，Process 1休眠。当内存中有足够的空间可以容纳写入数据，或内存被解锁时（即Process 2唤醒Process 1时），Process 1被唤醒。当数据写入内存之后，释放锁，唤醒等待中的Process 2（如果有的话）。

在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS索引节点又指向一个物理页面而实现的。

![管道与文件系统](http://pic002.cnblogs.com/images/2012/426620/2012110217010645.gif)

有两个 file 数据结构，但它们定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。这样，用户程序的系统调用仍然是通常的文件操作，而内核却利用这种抽象机制实现了管道这一特殊操作。

## 练习二

### 完成基于文件系统的执行程序机制的实现

proc.c中需要做如下修改：

- alloc_proc()

增加对于filesp内容的初始化。

- do_fork()

增加对于filesp的复制处理。直接调用实现好的函数即可。

- load_icode()

首先需要为新进程创建mm和PDT，这和之前的实现一致。然后要调用load_icode_read加载elf格式文件，并进行magic_number的判断。接着对于每一个程序段如下完成操作：load_icode_read加载程序起始段，创建vma，分配内存，读入程序段。最后进行堆栈分配，设置mm，cr3等寄存器，并将argc和argv的值放入栈中，设置trapframe即可。

具体实现见代码。
