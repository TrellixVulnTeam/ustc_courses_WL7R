# lab3 report 

## 练习1：给未被映射的地址映射上物理页

处理流程是：
1. 检查页表中是否有相应的表项，如果表项为空，则说明没有映射过
2. 为没有映射的虚拟页分配一个物理页，并确认分到的物理页不为空

* 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。

表项中`PTE_A`表示内存页是否被访问过，`PTE_D`表示内存页是否被修改过，这两个标志位可以成为局部页替换算法选取换出页的依据。

* 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

对于新出现的缺页异常处理流程和第一次出现缺页异常一样，即硬件将引发页访问异常的地址将被保存在cr2寄存器中，设置错误代码，然后触发Page Fault异常，进入缺页服务例程。当缺页服务例程完成后，经返回发生缺页异常的缺页服务例程使其继续执行。

## 练习2：补充完成基于FIFO的页面替换算法

FIFO基于双向链表实现，对于新加载的物理页所以只需要将页面插入到头节点之前。换出时选择
双向链表中头部节点后面的第一个节点，将其删除，并返回对应的页地址（虚拟地址）。

页缺失异常中，如果页表项存在，那么这一页已经映射过了但是被换出到磁盘中，需要将这一页内存换入。首先调用`swap_in`将内存页从磁盘中载入内存，然后调用`page_insert`建立物理地址与线性地址之间的映射并设置页对应的虚拟地址，最后调用`swap_map_swappable`将物理页框加入FIFO链表即可。

如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题：

是，设计方案见拓展练习。

* 需要被换出的页的特征是什么？
对于每个页面都有两个标志位，分别为使用位和修改位。换出页的使用位必须为0，表示该页在之前一段时间未被使用。并且算法优先考虑换出修改位为零的页面，以免频繁地将内存中的物理页写入磁盘而增大开销。

* 在ucore中如何判断具有这样特征的页？

当内存页被访问后，MMU将在对应的页表项的`PTE_A`这一位设为1，当内存页被修改后，MMU将在对应的页表项的`PTE_D`这一位设为1。

* 何时进行换入和换出操作？

当进程访问的物理页没有在内存中缓存而是保存在磁盘中时，需要进行换入操作；
当位于物理页中的内存被页面替换算法选择换出时，需要进行换出操作。

## Challenge：实现识别dirty bit的 extended clock页替换算法

Extended Clock算法利用双向链表作为一个环形链表。因为双向链表中每个结点都有实际意义，因此不再维护原本链表中的头指针，只用一个指针来指向在链表上将要访问的结点。当一个新的物理页被加载时，如果环形链表为空，那么这个页面就是整个链表，将指针指向这个页面，否则，将页面插入链表中指针指向的页面之前即可。

Extended Clock算法最多需要遍历环形链表四次。首先，查找未被访问且未被修改的页面，找到则换出。否则，查找未被访问但被修改的页面，并将查找过程中将所有页面都置为未被访问位，找到则换出。否则，查找未被访问且未被修改的页面，找到则换出。否则，再次查找未被访问但被修改的页面，这次一定能找到。需要注意的一点是，将页表项中的访问位置零后，刷新TLB，否则当页面被再次访问的时候，页表项中的访问位不会被置一。

代码可见/lab3/kern/mm/swap_clock.c，测试该代码将/lab3/kern/mm/swap.c第42行和第43行的注释交换即可。测试函数中，在原有FIFO算法的测试中追加了几项针对Extended Clock算法的测试。